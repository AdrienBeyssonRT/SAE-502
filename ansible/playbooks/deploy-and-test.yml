---
- name: DÃ©ploiement complet et test automatisÃ© du systÃ¨me de logs UFW
  hosts: all
  become: yes
  vars:
    playbook_dir: "{{ playbook_dir | default(ansible_env.PWD | default('/tmp')) }}/ansible/playbooks"
    project_root: "{{ playbook_dir | dirname | dirname }}"
    firewall_host: "firewall"
    client_container: "client"
    firewall_container: "firewall"
    logcollector_container: "logcollector"
    supervision_container: "supervision"
  
  tasks:
    - name: Afficher le dÃ©but du dÃ©ploiement
      debug:
        msg:
          - "=========================================="
          - "  DÃ‰PLOIEMENT COMPLET ET TEST AUTOMATISÃ‰"
          - "=========================================="
          - "Ce playbook automatise :"
          - "  1. Reconstruction des conteneurs"
          - "  2. DÃ©marrage de l'infrastructure"
          - "  3. Configuration UFW avec logging"
          - "  4. GÃ©nÃ©ration de trafic pour crÃ©er des logs"
          - "  5. VÃ©rification complÃ¨te de la chaÃ®ne de logs"
          - "  6. VÃ©rification de la catÃ©gorisation (BLOCK/ALLOW)"
          - ""

    # ==========================================
    # Ã‰TAPE 1 : DÃ‰TECTION DE DOCKER COMPOSE
    # ==========================================
    - name: DÃ©terminer le chemin du projet
      set_fact:
        project_root: "{{ playbook_dir | dirname | dirname | default(ansible_env.PWD | default('/tmp')) }}"

    - name: VÃ©rifier quel format docker-compose est disponible
      command: docker-compose --version
      register: docker_compose_available
      changed_when: false
      failed_when: false

    - name: DÃ©finir la commande docker-compose Ã  utiliser
      set_fact:
        docker_compose_cmd: "{{ 'docker-compose' if docker_compose_available.rc == 0 else 'docker compose' }}"
        docker_compose_file: "{{ project_root }}/docker-compose.yml"

    # ==========================================
    # Ã‰TAPE 2 : RECONSTRUCTION DES CONTENEURS
    # ==========================================
    - name: ArrÃªter les conteneurs existants
      command: "{{ docker_compose_cmd }} -f {{ docker_compose_file }} down"
      register: stop_result
      changed_when: stop_result.rc == 0
      failed_when: false

    - name: Reconstruire les conteneurs avec les nouvelles configurations
      command: "{{ docker_compose_cmd }} -f {{ docker_compose_file }} build --no-cache"
      register: build_result

    - name: DÃ©marrer les conteneurs
      command: "{{ docker_compose_cmd }} -f {{ docker_compose_file }} up -d"
      register: start_result

    - name: Attendre que les conteneurs soient prÃªts
      pause:
        seconds: 15

    - name: VÃ©rifier que tous les conteneurs sont en cours d'exÃ©cution
      command: docker ps --format "{{ '{{' }}.Names{{ '}}' }}"
      register: running_containers
      changed_when: false

    - name: Afficher les conteneurs en cours d'exÃ©cution
      debug:
        msg: "Conteneurs actifs: {{ running_containers.stdout_lines }}"

    # ==========================================
    # Ã‰TAPE 2 : CONFIGURATION UFW
    # ==========================================
    - name: Attendre que le firewall soit complÃ¨tement dÃ©marrÃ©
      pause:
        seconds: 5

    - name: VÃ©rifier le statut UFW
      command: docker exec {{ firewall_container }} ufw status verbose
      register: ufw_status
      changed_when: false
      failed_when: false

    - name: Afficher le statut UFW actuel
      debug:
        var: ufw_status.stdout_lines

    - name: Activer le logging UFW au niveau high
      command: docker exec {{ firewall_container }} ufw logging high
      register: ufw_logging
      changed_when: "'Logging: on (high)' not in ufw_status.stdout"
      failed_when: false

    - name: VÃ©rifier que le logging est activÃ©
      command: docker exec {{ firewall_container }} ufw status verbose | grep -i logging
      register: logging_check
      changed_when: false
      failed_when: false

    - name: Afficher le statut du logging
      debug:
        msg: "{{ logging_check.stdout }}"

    - name: Nettoyer les anciens logs pour un test propre
      command: docker exec {{ firewall_container }} sh -c "echo '' > /var/log/kern.log"
      changed_when: false
      failed_when: false

    # ==========================================
    # Ã‰TAPE 3 : VÃ‰RIFICATION DES SERVICES
    # ==========================================
    - name: VÃ©rifier que rsyslog fonctionne dans le firewall
      command: docker exec {{ firewall_container }} ps aux | grep rsyslog | grep -v grep
      register: rsyslog_firewall
      changed_when: false
      failed_when: false

    - name: Afficher le statut rsyslog dans le firewall
      debug:
        msg: "{{ 'rsyslog fonctionne' if rsyslog_firewall.rc == 0 else 'rsyslog ne fonctionne pas' }}"

    - name: VÃ©rifier que rsyslog fonctionne dans le logcollector
      command: docker exec {{ logcollector_container }} ps aux | grep rsyslog | grep -v grep
      register: rsyslog_logcollector
      changed_when: false
      failed_when: false

    - name: Afficher le statut rsyslog dans le logcollector
      debug:
        msg: "{{ 'rsyslog fonctionne' if rsyslog_logcollector.rc == 0 else 'rsyslog ne fonctionne pas' }}"

    - name: VÃ©rifier la connexion rÃ©seau entre firewall et logcollector
      command: docker exec {{ firewall_container }} ping -c 2 {{ logcollector_container }}
      register: network_check
      changed_when: false
      failed_when: false

    - name: Afficher le rÃ©sultat du test rÃ©seau
      debug:
        msg: "{{ 'Connexion rÃ©seau OK' if network_check.rc == 0 else 'ProblÃ¨me de connexion rÃ©seau' }}"

    # ==========================================
    # Ã‰TAPE 4 : GÃ‰NÃ‰RATION DE TRAFIC
    # ==========================================
    - name: GÃ©nÃ©rer du trafic pour crÃ©er des logs UFW
      command: docker exec {{ client_container }} /usr/local/bin/force-ufw-logs.sh {{ firewall_host }} 5
      register: traffic_result
      changed_when: false
      failed_when: false

    - name: Afficher le rÃ©sultat de la gÃ©nÃ©ration de trafic
      debug:
        msg: "{{ traffic_result.stdout_lines }}"

    # ==========================================
    # Ã‰TAPE 5 : VÃ‰RIFICATION DES LOGS
    # ==========================================
    - name: Attendre que les logs soient Ã©crits
      pause:
        seconds: 5

    - name: VÃ©rifier les logs UFW dans le firewall
      command: docker exec {{ firewall_container }} tail -100 /var/log/kern.log | grep -i ufw
      register: ufw_logs
      changed_when: false
      failed_when: false

    - name: Compter les logs UFW dans le firewall
      set_fact:
        firewall_log_count: "{{ ufw_logs.stdout_lines | length }}"

    - name: Afficher le nombre de logs UFW dans le firewall
      debug:
        msg: "{{ firewall_log_count }} logs UFW trouvÃ©s dans le firewall"

    - name: Afficher des exemples de logs UFW du firewall
      debug:
        msg: "{{ ufw_logs.stdout_lines[:5] }}"
      when: ufw_logs.stdout_lines | length > 0

    - name: VÃ©rifier que des logs UFW ont Ã©tÃ© gÃ©nÃ©rÃ©s
      fail:
        msg:
          - "âŒ ERREUR: Aucun log UFW trouvÃ© dans le firewall"
          - "VÃ©rifiez que:"
          - "  1. UFW est actif: docker exec {{ firewall_container }} ufw status"
          - "  2. Le logging est activÃ©: docker exec {{ firewall_container }} ufw status verbose | grep Logging"
          - "  3. Les rÃ¨gles UFW sont correctes"
      when: firewall_log_count | int == 0

    - name: Attendre que les logs soient envoyÃ©s au collecteur
      pause:
        seconds: 3

    - name: VÃ©rifier les logs dans le collecteur
      shell: docker exec {{ logcollector_container }} sh -c "tail -100 /var/log/firewall/*.log 2>/dev/null | grep -i ufw" || echo ""
      register: collector_logs
      changed_when: false
      failed_when: false

    - name: Compter les logs dans le collecteur
      set_fact:
        collector_log_count: "{{ collector_logs.stdout_lines | length }}"

    - name: Afficher le nombre de logs dans le collecteur
      debug:
        msg: "{{ collector_log_count }} logs UFW trouvÃ©s dans le collecteur"

    - name: Afficher des exemples de logs du collecteur
      debug:
        msg: "{{ collector_logs.stdout_lines[:5] }}"
      when: collector_logs.stdout_lines | length > 0

    # ==========================================
    # Ã‰TAPE 6 : VÃ‰RIFICATION DE LA SUPERVISION
    # ==========================================
    - name: Attendre que l'application de supervision soit prÃªte
      pause:
        seconds: 3

    - name: VÃ©rifier l'API de supervision - Statistiques
      uri:
        url: http://localhost:5000/api/stats
        method: GET
      register: supervision_stats
      changed_when: false
      failed_when: false
      retries: 5
      delay: 2

    - name: Afficher les statistiques de supervision
      debug:
        msg:
          - "Statistiques de supervision:"
          - "  Total de logs parsÃ©s: {{ supervision_stats.json.total | default(0) }}"
          - "  Tentatives bloquÃ©es (BLOCK): {{ supervision_stats.json.blocked_attempts | default(0) }}"
          - "  Connexions autorisÃ©es (ALLOW): {{ supervision_stats.json.allowed_connections | default(0) }}"
          - "  RÃ©partition par action: {{ supervision_stats.json.by_action | default({}) }}"
          - "  Top IP sources: {{ (supervision_stats.json.by_src_ip | default({}) | dict2items | sort(attribute='value', reverse=true) | list | map(attribute='key') | list)[:5] }}"
          - "  Top ports: {{ (supervision_stats.json.by_dport | default({}) | dict2items | sort(attribute='value', reverse=true) | list | map(attribute='key') | list)[:5] }}"

    - name: VÃ©rifier l'API de supervision - Debug
      uri:
        url: http://localhost:5000/api/debug
        method: GET
      register: debug_info
      changed_when: false
      failed_when: false

    - name: Afficher les informations de debug
      debug:
        msg:
          - "Informations de debug:"
          - "  RÃ©pertoire de logs: {{ debug_info.json.log_dir | default('N/A') }}"
          - "  RÃ©pertoire existe: {{ debug_info.json.log_dir_exists | default(false) }}"
          - "  Fichiers de logs: {{ debug_info.json.log_files | default([]) }}"
          - "  Total de lignes lues: {{ debug_info.json.total_lines | default(0) }}"
          - "  Logs parsÃ©s avec succÃ¨s: {{ debug_info.json.parsed_count | default(0) }}"
      when: debug_info.json is defined

    - name: VÃ©rifier l'API de supervision - Logs rÃ©cents
      uri:
        url: http://localhost:5000/api/recent
        method: GET
      register: recent_logs
      changed_when: false
      failed_when: false

    - name: Compter les logs rÃ©cents parsÃ©s
      set_fact:
        parsed_log_count: "{{ recent_logs.json | length | default(0) }}"

    - name: Afficher des exemples de logs parsÃ©s
      debug:
        msg:
          - "Exemples de logs parsÃ©s ({{ parsed_log_count }} au total):"
          - "{{ recent_logs.json[:3] | default([]) }}"
      when: recent_logs.json is defined and recent_logs.json | length > 0

    # ==========================================
    # Ã‰TAPE 7 : VÃ‰RIFICATION DE LA CATÃ‰GORISATION
    # ==========================================
    - name: VÃ©rifier la catÃ©gorisation des logs
      set_fact:
        logs_by_action: "{{ recent_logs.json | default([]) | groupby('action') | map('first') | list }}"

    - name: Compter les logs par catÃ©gorie
      set_fact:
        block_count: "{{ recent_logs.json | default([]) | selectattr('action', 'equalto', 'BLOCK') | list | length }}"
        allow_count: "{{ recent_logs.json | default([]) | selectattr('action', 'equalto', 'ALLOW') | list | length }}"
        limit_count: "{{ recent_logs.json | default([]) | selectattr('action', 'equalto', 'LIMIT') | list | length }}"
        network_count: "{{ recent_logs.json | default([]) | selectattr('action', 'equalto', 'NETWORK') | list | length }}"

    - name: Afficher la rÃ©partition par catÃ©gorie
      debug:
        msg:
          - "RÃ©partition des logs par catÃ©gorie:"
          - "  BLOCK (bloquÃ©s): {{ block_count }}"
          - "  ALLOW (autorisÃ©s): {{ allow_count }}"
          - "  LIMIT (limitÃ©s): {{ limit_count }}"
          - "  NETWORK (rÃ©seau): {{ network_count }}"

    - name: VÃ©rifier qu'il y a des logs BLOCK
      debug:
        msg: "âœ… Des logs BLOCK ont Ã©tÃ© dÃ©tectÃ©s (ports bloquÃ©s: 445, 3389, 139, 80)"
      when: block_count | int > 0

    - name: VÃ©rifier qu'il y a des logs ALLOW
      debug:
        msg: "âœ… Des logs ALLOW ont Ã©tÃ© dÃ©tectÃ©s (port autorisÃ©: 22 depuis rÃ©seau interne)"
      when: allow_count | int > 0

    # ==========================================
    # RÃ‰SUMÃ‰ FINAL
    # ==========================================
    - name: RÃ©sumÃ© final du dÃ©ploiement et des tests
      debug:
        msg:
          - ""
          - "=========================================="
          - "  RÃ‰SUMÃ‰ FINAL"
          - "=========================================="
          - "âœ… Conteneurs: Tous dÃ©marrÃ©s"
          - "{{ 'âœ…' if (firewall_log_count | int > 0) else 'âŒ' }} Logs UFW dans le firewall: {{ firewall_log_count }} logs"
          - "{{ 'âœ…' if (collector_log_count | int > 0) else 'âš ï¸ ' }} Logs dans le collecteur: {{ collector_log_count }} logs"
          - "{{ 'âœ…' if (parsed_log_count | int > 0) else 'âš ï¸ ' }} Logs parsÃ©s par la supervision: {{ parsed_log_count }} logs"
          - ""
          - "ðŸ“Š CatÃ©gorisation:"
          - "  BLOCK: {{ block_count }} logs"
          - "  ALLOW: {{ allow_count }} logs"
          - "  LIMIT: {{ limit_count }} logs"
          - "  NETWORK: {{ network_count }} logs"
          - ""
          - "ðŸŒ Interface web disponible sur: http://localhost:5000"
          - ""
          - "Pour voir les logs en temps rÃ©el:"
          - "  docker exec {{ firewall_container }} tail -f /var/log/kern.log | grep UFW"
          - "  docker exec {{ logcollector_container }} tail -f /var/log/firewall/*.log | grep UFW"
          - ""

    - name: VÃ©rification finale - Tous les tests sont passÃ©s
      debug:
        msg:
          - "âœ… DÃ‰PLOIEMENT ET TESTS RÃ‰USSIS!"
          - "Le systÃ¨me est opÃ©rationnel et les logs sont correctement catÃ©gorisÃ©s."
      when: 
        - firewall_log_count | int > 0
        - parsed_log_count | int > 0

